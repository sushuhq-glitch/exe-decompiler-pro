/**
 * ============================================================================
 * EXPLOIT DETECTOR - SECURITY VULNERABILITY DETECTION
 * ============================================================================
 * 
 * Detects common security vulnerabilities and exploit patterns in binary code:
 * - Buffer overflow patterns
 * - Format string vulnerabilities
 * - Shellcode signatures
 * - ROP chains
 * - Heap spray patterns
 * - Use-after-free
 * - Integer overflow
 * - Stack canary bypass attempts
 * - DEP/ASLR bypass techniques
 * 
 * @author Exploit Detection Engine
 * @version 1.0.0
 */

// Detection thresholds and constants
const ENTROPY_THRESHOLD = 7.0; // High entropy threshold for packed/encrypted code (0-8 scale)
const ROP_GADGET_THRESHOLD = 20; // Minimum number of ROP gadgets to flag as suspicious

/**
 * Main exploit detection function
 */
export function detectExploits(binaryData, peData, functions) {
  console.log('ðŸ›¡ï¸ Starting exploit detection...');
  
  const detector = new ExploitDetector(binaryData, peData, functions);
  const results = detector.analyze();
  
  console.log(`âœ“ Found ${results.vulnerabilities.length} potential vulnerabilities`);
  
  return results;
}

/**
 * ExploitDetector Class
 */
class ExploitDetector {
  constructor(binaryData, peData, functions) {
    this.binaryData = binaryData;
    this.peData = peData;
    this.functions = functions || [];
    this.vulnerabilities = [];
    this.warnings = [];
    this.info = [];
  }
  
  /**
   * Run all detection modules
   */
  analyze() {
    this.detectBufferOverflows();
    this.detectFormatStrings();
    this.detectShellcode();
    this.detectROPChains();
    this.detectHeapSpray();
    this.detectUseAfterFree();
    this.detectIntegerOverflows();
    this.detectStackCanaryBypass();
    this.detectDEPBypass();
    this.detectASLRBypass();
    this.detectDangerousFunctions();
    this.analyzeSecurityFeatures();
    
    return {
      vulnerabilities: this.vulnerabilities,
      warnings: this.warnings,
      info: this.info,
      summary: this.generateSummary()
    };
  }
  
  /**
   * Detect buffer overflow patterns
   */
  detectBufferOverflows() {
    const dangerousFunctions = [
      'strcpy', 'strcat', 'sprintf', 'vsprintf',
      'gets', 'scanf', 'fscanf', 'sscanf'
    ];
    
    // Check imports for dangerous functions
    if (this.peData && this.peData.imports) {
      for (const imp of this.peData.imports) {
        if (dangerousFunctions.some(func => imp.name && imp.name.includes(func))) {
          this.vulnerabilities.push({
            type: 'BUFFER_OVERFLOW',
            severity: 'HIGH',
            title: 'Unsafe String Function',
            description: `Function ${imp.name} is unsafe and can lead to buffer overflows`,
            recommendation: 'Replace with safe alternatives: strncpy, strncat, snprintf',
            location: `Import from ${imp.dll}`,
            cwe: 'CWE-120'
          });
        }
      }
    }
    
    // Analyze functions for unbounded copies
    for (const func of this.functions) {
      if (func.instructions) {
        const hasMovsb = func.instructions.some(inst => 
          inst.mnemonic === 'movsb' || inst.mnemonic === 'rep movsb'
        );
        
        const hasLengthCheck = func.instructions.some(inst =>
          inst.mnemonic === 'cmp' || inst.mnemonic === 'test'
        );
        
        if (hasMovsb && !hasLengthCheck) {
          this.vulnerabilities.push({
            type: 'BUFFER_OVERFLOW',
            severity: 'MEDIUM',
            title: 'Unchecked Memory Copy',
            description: `Function ${func.name} performs memory copy without length validation`,
            recommendation: 'Add bounds checking before memory operations',
            location: `Function at 0x${func.address.toString(16)}`,
            cwe: 'CWE-120'
          });
        }
      }
    }
  }
  
  /**
   * Detect format string vulnerabilities
   */
  detectFormatStrings() {
    const printfFunctions = ['printf', 'fprintf', 'sprintf', 'snprintf', 'vprintf'];
    
    if (this.peData && this.peData.imports) {
      for (const imp of this.peData.imports) {
        if (printfFunctions.some(func => imp.name && imp.name.includes(func))) {
          this.vulnerabilities.push({
            type: 'FORMAT_STRING',
            severity: 'HIGH',
            title: 'Potential Format String Vulnerability',
            description: `Function ${imp.name} may be vulnerable if user input is used as format string`,
            recommendation: 'Always use constant format strings, never pass user input directly',
            location: `Import from ${imp.dll}`,
            cwe: 'CWE-134'
          });
        }
      }
    }
    
    // Look for format string patterns in code
    for (const func of this.functions) {
      if (func.instructions) {
        // Look for patterns where a pointer is passed without a format string
        let hasFormatFunc = false;
        let hasConstantFormat = false;
        
        for (let i = 0; i < func.instructions.length; i++) {
          const inst = func.instructions[i];
          
          if (inst.type === 'call') {
            hasFormatFunc = true;
            
            // Check previous instructions for constant string push
            if (i > 0) {
              const prev = func.instructions[i - 1];
              if (prev.mnemonic === 'push' && prev.operands[0]?.type === 'imm') {
                hasConstantFormat = true;
              }
            }
          }
        }
        
        if (hasFormatFunc && !hasConstantFormat) {
          this.warnings.push({
            type: 'FORMAT_STRING',
            severity: 'MEDIUM',
            title: 'Possible Format String Usage',
            description: `Function ${func.name} may use format strings - verify format string is constant`,
            recommendation: 'Review format string usage in this function',
            location: `Function at 0x${func.address.toString(16)}`,
            cwe: 'CWE-134'
          });
        }
      }
    }
  }
  
  /**
   * Detect shellcode signatures
   */
  detectShellcode() {
    const shellcodePatterns = [
      // Common shellcode patterns
      { pattern: [0x90, 0x90, 0x90, 0x90], name: 'NOP sled', minCount: 10 },
      { pattern: [0xEB, 0xFE], name: 'Infinite loop (JMP $)' },
      { pattern: [0xCC], name: 'Breakpoint instruction', minCount: 5 },
      // GetPC code
      { pattern: [0xE8, 0x00, 0x00, 0x00, 0x00, 0x58], name: 'GetPC (call $+5; pop eax)' },
      // Egg hunters
      { pattern: [0x66, 0x81, 0xCA, 0xFF, 0x0F], name: 'Egg hunter pattern' }
    ];
    
    for (const shellPattern of shellcodePatterns) {
      const occurrences = this.findPatternOccurrences(shellPattern.pattern);
      const minCount = shellPattern.minCount || 1;
      
      if (occurrences.length >= minCount) {
        this.vulnerabilities.push({
          type: 'SHELLCODE',
          severity: 'CRITICAL',
          title: 'Shellcode Pattern Detected',
          description: `Found ${occurrences.length} occurrences of "${shellPattern.name}"`,
          recommendation: 'Investigate if this is legitimate code or injected shellcode',
          location: `Addresses: ${occurrences.slice(0, 5).map(a => '0x' + a.toString(16)).join(', ')}${occurrences.length > 5 ? '...' : ''}`,
          cwe: 'CWE-94'
        });
      }
    }
    
    // Check for executable sections with high entropy (possible packed shellcode)
    if (this.peData && this.peData.sections) {
      for (const section of this.peData.sections) {
        if (section.characteristics && (section.characteristics & 0x20000000)) { // IMAGE_SCN_MEM_EXECUTE
          const entropy = this.calculateEntropy(section.data);
          if (entropy > ENTROPY_THRESHOLD) {
            this.warnings.push({
              type: 'SHELLCODE',
              severity: 'MEDIUM',
              title: 'High Entropy in Executable Section',
              description: `Section ${section.name} has entropy ${entropy.toFixed(2)} - may contain packed/encrypted code`,
              recommendation: 'Analyze for potential shellcode or packing',
              location: `Section ${section.name}`,
              cwe: 'CWE-94'
            });
          }
        }
      }
    }
  }
  
  /**
   * Detect ROP (Return-Oriented Programming) chains
   */
  detectROPChains() {
    // Look for sequences of RET instructions
    let retCount = 0;
    let retSequences = [];
    let currentSequence = [];
    
    for (let i = 0; i < this.binaryData.length - 1; i++) {
      if (this.binaryData[i] === 0xC3) { // RET instruction
        retCount++;
        currentSequence.push(i);
        
        // Check if next instruction is also RET or close by
        if (i + 1 < this.binaryData.length) {
          const nextBytes = this.binaryData.slice(i + 1, Math.min(i + 20, this.binaryData.length));
          const nextRetOffset = nextBytes.indexOf(0xC3);
          
          if (nextRetOffset >= 0 && nextRetOffset < 15) {
            // Continue sequence
          } else {
            if (currentSequence.length >= 5) {
              retSequences.push([...currentSequence]);
            }
            currentSequence = [];
          }
        }
      }
    }
    
    if (retSequences.length > 0) {
      this.vulnerabilities.push({
        type: 'ROP_CHAIN',
        severity: 'HIGH',
        title: 'Potential ROP Chain Detected',
        description: `Found ${retSequences.length} sequences of multiple RET instructions`,
        recommendation: 'Verify if these are legitimate gadgets or potential ROP chain',
        location: `${retSequences.length} sequences found`,
        cwe: 'CWE-94'
      });
    }
    
    // Look for ROP gadgets (useful instruction sequences ending in RET)
    const gadgetPatterns = [
      { pattern: [0x58, 0xC3], name: 'pop eax; ret' },
      { pattern: [0x5B, 0xC3], name: 'pop ebx; ret' },
      { pattern: [0x5D, 0xC3], name: 'pop ebp; ret' },
      { pattern: [0x89, 0xE5, 0xC3], name: 'mov ebp, esp; ret' },
      { pattern: [0x31, 0xC0, 0xC3], name: 'xor eax, eax; ret' }
    ];
    
    let gadgetCount = 0;
    for (const gadget of gadgetPatterns) {
      const occurrences = this.findPatternOccurrences(gadget.pattern);
      gadgetCount += occurrences.length;
    }
    
    if (gadgetCount > ROP_GADGET_THRESHOLD) {
      this.warnings.push({
        type: 'ROP_CHAIN',
        severity: 'MEDIUM',
        title: 'High Number of ROP Gadgets',
        description: `Found ${gadgetCount} potential ROP gadgets in binary`,
        recommendation: 'Binary may be vulnerable to ROP attacks',
        location: `${gadgetCount} gadgets found`,
        cwe: 'CWE-94'
      });
    }
  }
  
  /**
   * Detect heap spray patterns
   */
  detectHeapSpray() {
    // Look for large allocations
    const allocFunctions = ['malloc', 'calloc', 'realloc', 'HeapAlloc', 'VirtualAlloc'];
    
    if (this.peData && this.peData.imports) {
      for (const imp of this.peData.imports) {
        if (allocFunctions.some(func => imp.name && imp.name.includes(func))) {
          this.info.push({
            type: 'HEAP_SPRAY',
            severity: 'LOW',
            title: 'Heap Allocation Function',
            description: `Binary uses ${imp.name} - monitor for large/repeated allocations`,
            recommendation: 'Ensure heap allocations are properly sized and validated',
            location: `Import from ${imp.dll}`,
            cwe: 'CWE-122'
          });
        }
      }
    }
    
    // Look for repeated patterns in data sections (potential spray pattern)
    if (this.peData && this.peData.sections) {
      for (const section of this.peData.sections) {
        if (section.data && section.data.length > 1000) {
          const repeatedPatterns = this.findRepeatedPatterns(section.data);
          if (repeatedPatterns.length > 0) {
            this.warnings.push({
              type: 'HEAP_SPRAY',
              severity: 'MEDIUM',
              title: 'Repeated Pattern in Data Section',
              description: `Section ${section.name} contains ${repeatedPatterns.length} repeated patterns`,
              recommendation: 'Verify if pattern is legitimate or potential heap spray',
              location: `Section ${section.name}`,
              cwe: 'CWE-122'
            });
          }
        }
      }
    }
  }
  
  /**
   * Detect use-after-free patterns
   */
  detectUseAfterFree() {
    const freeFunctions = ['free', 'delete', 'HeapFree'];
    
    for (const func of this.functions) {
      if (func.instructions) {
        let freeAddresses = [];
        let useAfterFree = false;
        
        for (let i = 0; i < func.instructions.length; i++) {
          const inst = func.instructions[i];
          
          // Track free calls
          if (inst.type === 'call') {
            // Check if it's a free function
            const isFree = freeFunctions.some(f => 
              inst.operands && inst.operands.some(op => 
                op.value && op.value.toString().includes(f)
              )
            );
            
            if (isFree) {
              freeAddresses.push(i);
            }
          }
          
          // Look for pointer usage after free
          if (freeAddresses.length > 0) {
            // Check if same pointer is used again
            if (inst.type === 'mem' || inst.mnemonic === 'mov') {
              useAfterFree = true;
            }
          }
        }
        
        if (useAfterFree) {
          this.vulnerabilities.push({
            type: 'USE_AFTER_FREE',
            severity: 'HIGH',
            title: 'Potential Use-After-Free',
            description: `Function ${func.name} may use memory after freeing it`,
            recommendation: 'Set pointers to NULL after freeing',
            location: `Function at 0x${func.address.toString(16)}`,
            cwe: 'CWE-416'
          });
        }
      }
    }
  }
  
  /**
   * Detect integer overflow patterns
   */
  detectIntegerOverflows() {
    for (const func of this.functions) {
      if (func.instructions) {
        let hasArithmetic = false;
        let hasOverflowCheck = false;
        
        for (const inst of func.instructions) {
          // Look for arithmetic operations
          if (['add', 'sub', 'mul', 'imul', 'shl', 'shr'].includes(inst.mnemonic)) {
            hasArithmetic = true;
          }
          
          // Look for overflow checks (jo = jump if overflow)
          if (inst.mnemonic === 'jo' || inst.mnemonic === 'jno') {
            hasOverflowCheck = true;
          }
        }
        
        if (hasArithmetic && !hasOverflowCheck) {
          this.warnings.push({
            type: 'INTEGER_OVERFLOW',
            severity: 'MEDIUM',
            title: 'Unchecked Integer Operation',
            description: `Function ${func.name} performs arithmetic without overflow checking`,
            recommendation: 'Add overflow detection for arithmetic operations',
            location: `Function at 0x${func.address.toString(16)}`,
            cwe: 'CWE-190'
          });
        }
      }
    }
  }
  
  /**
   * Detect stack canary bypass attempts
   */
  detectStackCanaryBypass() {
    const canaryFunctions = ['__security_check_cookie', '__stack_chk_fail', '__stack_chk_guard'];
    
    let hasCanary = false;
    
    if (this.peData && this.peData.imports) {
      for (const imp of this.peData.imports) {
        if (canaryFunctions.some(func => imp.name && imp.name.includes(func))) {
          hasCanary = true;
          break;
        }
      }
    }
    
    if (hasCanary) {
      this.info.push({
        type: 'STACK_CANARY',
        severity: 'INFO',
        title: 'Stack Canary Detected',
        description: 'Binary uses stack canaries for buffer overflow protection',
        recommendation: 'Stack protection is enabled - good security practice',
        location: 'Binary',
        cwe: 'N/A'
      });
    } else {
      this.warnings.push({
        type: 'STACK_CANARY',
        severity: 'MEDIUM',
        title: 'No Stack Canary Protection',
        description: 'Binary does not use stack canaries',
        recommendation: 'Compile with /GS (MSVC) or -fstack-protector (GCC) for stack protection',
        location: 'Binary',
        cwe: 'CWE-693'
      });
    }
  }
  
  /**
   * Detect DEP bypass techniques
   */
  detectDEPBypass() {
    const depBypassFunctions = ['VirtualProtect', 'VirtualAlloc', 'SetProcessDEPPolicy'];
    
    if (this.peData && this.peData.imports) {
      for (const imp of this.peData.imports) {
        if (depBypassFunctions.some(func => imp.name && imp.name.includes(func))) {
          this.vulnerabilities.push({
            type: 'DEP_BYPASS',
            severity: 'HIGH',
            title: 'Potential DEP Bypass',
            description: `Binary imports ${imp.name} which can modify memory protections`,
            recommendation: 'Verify legitimate use of memory protection functions',
            location: `Import from ${imp.dll}`,
            cwe: 'CWE-693'
          });
        }
      }
    }
  }
  
  /**
   * Detect ASLR bypass techniques
   */
  detectASLRBypass() {
    // Check if binary has relocation table
    if (this.peData) {
      const hasRelocations = this.peData.hasRelocations !== false;
      
      if (!hasRelocations) {
        this.warnings.push({
          type: 'ASLR_BYPASS',
          severity: 'MEDIUM',
          title: 'ASLR Not Supported',
          description: 'Binary lacks relocation table - ASLR cannot be used',
          recommendation: 'Compile with /DYNAMICBASE for ASLR support',
          location: 'Binary',
          cwe: 'CWE-693'
        });
      }
    }
  }
  
  /**
   * Detect dangerous function usage
   */
  detectDangerousFunctions() {
    const dangerousFuncs = [
      { name: 'system', reason: 'Can execute arbitrary commands', severity: 'CRITICAL' },
      { name: 'exec', reason: 'Can execute arbitrary programs', severity: 'CRITICAL' },
      { name: 'ShellExecute', reason: 'Can execute arbitrary programs', severity: 'CRITICAL' },
      { name: 'CreateProcess', reason: 'Can execute arbitrary programs', severity: 'HIGH' },
      { name: 'WinExec', reason: 'Can execute arbitrary commands', severity: 'HIGH' },
      { name: 'LoadLibrary', reason: 'Can load arbitrary DLLs', severity: 'MEDIUM' }
    ];
    
    if (this.peData && this.peData.imports) {
      for (const imp of this.peData.imports) {
        for (const dangerous of dangerousFuncs) {
          if (imp.name && imp.name.includes(dangerous.name)) {
            this.vulnerabilities.push({
              type: 'DANGEROUS_FUNCTION',
              severity: dangerous.severity,
              title: `Dangerous Function: ${dangerous.name}`,
              description: dangerous.reason,
              recommendation: 'Ensure user input is properly validated before use',
              location: `Import from ${imp.dll}`,
              cwe: 'CWE-78'
            });
          }
        }
      }
    }
  }
  
  /**
   * Analyze security features
   */
  analyzeSecurityFeatures() {
    const features = {
      aslr: false,
      dep: false,
      safeseh: false,
      cfg: false,
      gs: false
    };
    
    // Check PE characteristics
    if (this.peData) {
      features.aslr = this.peData.hasRelocations !== false;
      features.dep = this.peData.dllCharacteristics && (this.peData.dllCharacteristics & 0x0100) !== 0;
      features.safeseh = this.peData.dllCharacteristics && (this.peData.dllCharacteristics & 0x0400) !== 0;
      features.cfg = this.peData.dllCharacteristics && (this.peData.dllCharacteristics & 0x4000) !== 0;
    }
    
    // Check for stack canaries
    if (this.peData && this.peData.imports) {
      features.gs = this.peData.imports.some(imp => 
        imp.name && (imp.name.includes('__security_check_cookie') || imp.name.includes('__stack_chk'))
      );
    }
    
    this.info.push({
      type: 'SECURITY_FEATURES',
      severity: 'INFO',
      title: 'Security Features Summary',
      description: `ASLR: ${features.aslr ? 'âœ“' : 'âœ—'}, DEP: ${features.dep ? 'âœ“' : 'âœ—'}, SafeSEH: ${features.safeseh ? 'âœ“' : 'âœ—'}, CFG: ${features.cfg ? 'âœ“' : 'âœ—'}, /GS: ${features.gs ? 'âœ“' : 'âœ—'}`,
      recommendation: 'Enable all security features for maximum protection',
      location: 'Binary',
      cwe: 'N/A'
    });
  }
  
  /**
   * Find pattern occurrences in binary
   */
  findPatternOccurrences(pattern) {
    const occurrences = [];
    
    for (let i = 0; i <= this.binaryData.length - pattern.length; i++) {
      let match = true;
      for (let j = 0; j < pattern.length; j++) {
        if (this.binaryData[i + j] !== pattern[j]) {
          match = false;
          break;
        }
      }
      if (match) {
        occurrences.push(i);
      }
    }
    
    return occurrences;
  }
  
  /**
   * Calculate entropy of data (0-8, where 8 is maximum entropy)
   */
  calculateEntropy(data) {
    if (!data || data.length === 0) return 0;
    
    const freq = new Array(256).fill(0);
    for (const byte of data) {
      freq[byte]++;
    }
    
    let entropy = 0;
    for (const count of freq) {
      if (count > 0) {
        const p = count / data.length;
        entropy -= p * Math.log2(p);
      }
    }
    
    return entropy;
  }
  
  /**
   * Find repeated patterns in data
   */
  findRepeatedPatterns(data, minPatternLength = 4, minRepetitions = 10) {
    const patterns = [];
    
    // Simple pattern detection (sliding window)
    for (let len = minPatternLength; len <= 32; len++) {
      const patternCounts = new Map();
      
      for (let i = 0; i <= data.length - len; i++) {
        const pattern = data.slice(i, i + len).join(',');
        patternCounts.set(pattern, (patternCounts.get(pattern) || 0) + 1);
      }
      
      for (const [pattern, count] of patternCounts) {
        if (count >= minRepetitions) {
          patterns.push({ pattern, count, length: len });
        }
      }
    }
    
    return patterns;
  }
  
  /**
   * Generate summary
   */
  generateSummary() {
    const criticalCount = this.vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const highCount = this.vulnerabilities.filter(v => v.severity === 'HIGH').length;
    const mediumCount = this.vulnerabilities.filter(v => v.severity === 'MEDIUM').length;
    const lowCount = this.vulnerabilities.filter(v => v.severity === 'LOW').length;
    
    let riskLevel = 'LOW';
    if (criticalCount > 0) riskLevel = 'CRITICAL';
    else if (highCount > 0) riskLevel = 'HIGH';
    else if (mediumCount > 0) riskLevel = 'MEDIUM';
    
    return {
      riskLevel,
      totalIssues: this.vulnerabilities.length + this.warnings.length,
      criticalCount,
      highCount,
      mediumCount,
      lowCount,
      warningCount: this.warnings.length,
      infoCount: this.info.length
    };
  }
}

export default detectExploits;
