/**
 * JavaScript Decompiler - Convert assembly to modern JS
 * Generates ES6+ code with async/await and classes
 */

export function decompileToJavaScript(instructions, peData, functionInfo) {
  const ctx = {
    code: [],
    indent: 0,
    vars: new Map(),
    peData,
    functionInfo
  };

  generateFunctionHeader(ctx);
  generateVariables(ctx, instructions);

  for (let i = 0; i < instructions.length; i++) {
    processInstruction(ctx, instructions[i]);
  }

  addLine(ctx, 'return null;');
  ctx.indent = 0;
  ctx.code.push('}');

  return ctx.code.join('\n');
}

function generateFunctionHeader(ctx) {
  const funcName = jsizeName(ctx.functionInfo?.name || 'function');
  
  ctx.code.push('/**');
  ctx.code.push(` * ${funcName}`);
  if (ctx.functionInfo?.address) {
    ctx.code.push(` * @address 0x${ctx.functionInfo.address.toString(16)}`);
  }
  ctx.code.push(' * Decompiled from assembly');
  ctx.code.push(' */');
  ctx.code.push(`async function ${funcName}() {`);
  ctx.indent = 1;
}

function generateVariables(ctx, instructions) {
  const registers = ['eax', 'ebx', 'ecx', 'edx'];
  const usedRegs = new Set();

  for (const instr of instructions) {
    if (typeof instr === 'string') {
      for (const reg of registers) {
        if (instr.includes(reg)) {
          usedRegs.add(reg);
        }
      }
    }
  }

  if (usedRegs.size > 0) {
    addLine(ctx, '// Register variables');
    const regs = Array.from(usedRegs).join(', ');
    addLine(ctx, `let ${regs} = 0;`);
    addLine(ctx, '');
  }
}

function processInstruction(ctx, instr) {
  if (typeof instr !== 'string') return;
  
  const line = instr.trim();
  if (!line) return;

  addLine(ctx, `// ${line}`);

  const parts = line.split(/\s+/);
  const opcode = parts[0]?.toLowerCase();

  switch (opcode) {
    case 'mov':
      const ops = parts.slice(1).join(' ').split(',').map(s => s.trim());
      if (ops.length === 2) {
        addLine(ctx, `${ops[0]} = ${ops[1]};`);
      }
      break;
    case 'call':
      addLine(ctx, `await ${jsizeName(parts[1])}();`);
      break;
    default:
      addLine(ctx, `// TODO: ${opcode}`);
  }
}

function jsizeName(name) {
  return name.replace(/[^a-zA-Z0-9_]/g, '_');
}

function addLine(ctx, line) {
  const indent = '  '.repeat(ctx.indent);
  ctx.code.push(indent + line);
}

export function generateCompleteJavaScript(functions, peData) {
  let code = [];
  
  code.push('/**');
  code.push(' * Decompiled JavaScript');
  code.push(' * Generated by EXE Decompiler Pro');
  code.push(' */');
  code.push('');
  code.push('async function main() {');
  code.push('  console.log("Decompiled program");');
  code.push('}');
  code.push('');

  for (const func of functions) {
    code.push(func.code || '// Function code not available');
    code.push('');
  }

  code.push('main().catch(console.error);');

  return code.join('\n');
}
