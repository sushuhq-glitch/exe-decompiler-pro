/**
 * Python Decompiler - Convert assembly to Python code
 * Generates Pythonic code with type hints and clean indentation
 */

/**
 * Decompile to Python code
 * @param {Array} instructions - Assembly instructions
 * @param {Object} peData - PE file data
 * @param {Object} functionInfo - Function metadata
 * @returns {string} Python code
 */
export function decompileToPython(instructions, peData, functionInfo) {
  const ctx = {
    code: [],
    indent: 0,
    vars: new Map(),
    peData,
    functionInfo
  };

  // Generate function header
  generateFunctionHeader(ctx);

  // Generate variable declarations (Python style)
  generateVariables(ctx, instructions);

  // Process instructions
  for (let i = 0; i < instructions.length; i++) {
    const instr = instructions[i];
    processInstruction(ctx, instr);
  }

  // Add return statement
  addLine(ctx, 'return None');

  // Dedent
  ctx.indent = 0;

  // Add main block
  ctx.code.push('');
  ctx.code.push('');
  ctx.code.push('if __name__ == "__main__":');
  ctx.code.push(`    ${ctx.functionInfo?.name || 'main_function'}()`);

  return ctx.code.join('\n');
}

function generateFunctionHeader(ctx) {
  const funcName = pythonizeName(ctx.functionInfo?.name || 'function');
  
  ctx.code.push('#!/usr/bin/env python3');
  ctx.code.push('"""');
  ctx.code.push(`Function: ${funcName}`);
  if (ctx.functionInfo?.address) {
    ctx.code.push(`Address: 0x${ctx.functionInfo.address.toString(16)}`);
  }
  ctx.code.push('Decompiled from assembly');
  ctx.code.push('"""');
  ctx.code.push('');
  ctx.code.push('from typing import Optional, List, Dict');
  ctx.code.push('import ctypes');
  ctx.code.push('');
  ctx.code.push('');
  ctx.code.push(`def ${funcName}() -> Optional[int]:`);
  ctx.indent = 1;
  addLine(ctx, '"""Decompiled function"""');
}

function generateVariables(ctx, instructions) {
  const registers = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi', 'esp', 'ebp'];
  const usedRegs = new Set();

  for (const instr of instructions) {
    if (typeof instr === 'string') {
      for (const reg of registers) {
        if (instr.includes(reg)) {
          usedRegs.add(reg);
        }
      }
    }
  }

  if (usedRegs.size > 0) {
    addLine(ctx, '# Register variables');
    for (const reg of usedRegs) {
      addLine(ctx, `${reg}: int = 0`);
    }
    addLine(ctx, '');
  }
}

function processInstruction(ctx, instr) {
  if (typeof instr !== 'string') return;

  const line = instr.trim();
  if (!line) return;

  addLine(ctx, `# ${line}`);

  const parts = line.split(/\s+/);
  const opcode = parts[0]?.toLowerCase();

  switch (opcode) {
    case 'mov':
      handleMov(ctx, parts.slice(1).join(' '));
      break;
    case 'call':
      handleCall(ctx, parts[1]);
      break;
    case 'add':
    case 'sub':
      handleArithmetic(ctx, opcode, parts.slice(1).join(' '));
      break;
    case 'ret':
      break; // Will add return at end
    default:
      addLine(ctx, `# TODO: ${opcode}`);
  }
}

function handleMov(ctx, operands) {
  const [dest, src] = parseOperands(operands);
  if (dest && src) {
    addLine(ctx, `${pythonizeOperand(dest)} = ${pythonizeOperand(src)}`);
  }
}

function handleCall(ctx, target) {
  const funcName = pythonizeName(target);
  addLine(ctx, `${funcName}()`);
}

function handleArithmetic(ctx, opcode, operands) {
  const [dest, src] = parseOperands(operands);
  if (dest && src) {
    const op = opcode === 'add' ? '+' : '-';
    addLine(ctx, `${pythonizeOperand(dest)} ${op}= ${pythonizeOperand(src)}`);
  }
}

function parseOperands(operands) {
  return operands.split(',').map(s => s.trim());
}

function pythonizeOperand(op) {
  if (op.startsWith('0x')) return op;
  if (/^\d+$/.test(op)) return op;
  return op.replace(/[^a-zA-Z0-9_]/g, '_');
}

function pythonizeName(name) {
  return name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
}

function addLine(ctx, line) {
  const indent = '    '.repeat(ctx.indent);
  ctx.code.push(indent + line);
}

/**
 * Generate complete Python file
 */
export function generateCompletePython(functions, peData) {
  let code = [];
  
  code.push('#!/usr/bin/env python3');
  code.push('"""');
  code.push('Decompiled Python Code');
  code.push('Generated by EXE Decompiler Pro');
  code.push('"""');
  code.push('');
  code.push('from typing import Optional, List, Dict, Any');
  code.push('import ctypes');
  code.push('import struct');
  code.push('');
  code.push('');
  code.push('def main() -> None:');
  code.push('    """Entry point"""');
  code.push('    pass');
  code.push('');
  code.push('');

  for (const func of functions) {
    code.push(func.code || '# Function code not available');
    code.push('');
  }

  code.push('');
  code.push('if __name__ == "__main__":');
  code.push('    main()');

  return code.join('\n');
}
