/**
 * Malware Scorer - Calculate security risk score 0-100
 * Analyzes suspicious patterns and behaviors
 */

/**
 * Calculate malware score
 * @param {Object} peData - Parsed PE data
 * @param {Array} strings - Extracted strings
 * @param {Object} analysis - Complete analysis data
 * @returns {Object} Score and details
 */
export function calculateMalwareScore(peData, strings, analysis) {
  let score = 0;
  const findings = [];
  const details = {};

  // 1. Suspicious API calls (30 points max)
  const apiScore = checkSuspiciousAPIs(peData, findings);
  score += apiScore;
  details['Suspicious APIs'] = apiScore;

  // 2. Packer detection (15 points)
  const packerScore = checkPacker(peData, findings);
  score += packerScore;
  details['Packer Detected'] = packerScore > 0 ? 'Yes' : 'No';

  // 3. Anti-debugging (15 points)
  const debugScore = checkAntiDebugging(peData, strings, findings);
  score += debugScore;
  details['Anti-Debug'] = debugScore;

  // 4. Network activity (10 points)
  const networkScore = checkNetworkActivity(peData, strings, findings);
  score += networkScore;
  details['Network Activity'] = networkScore;

  // 5. Registry modification (10 points)
  const regScore = checkRegistryModification(peData, strings, findings);
  score += regScore;
  details['Registry Modification'] = regScore;

  // 6. Code injection patterns (10 points)
  const injectionScore = checkCodeInjection(peData, strings, findings);
  score += injectionScore;
  details['Code Injection'] = injectionScore;

  // 7. Obfuscation (5 points)
  const obfuscationScore = checkObfuscation(analysis, findings);
  score += obfuscationScore;
  details['Obfuscation'] = obfuscationScore;

  // 8. Entropy analysis (5 points)
  const entropyScore = checkEntropy(peData, findings);
  score += entropyScore;
  details['High Entropy'] = entropyScore;

  // Cap score at 100
  score = Math.min(score, 100);

  // Generate summary
  const summary = generateSummary(score, findings);

  // Generate recommendations
  const recommendations = generateRecommendations(findings);

  return {
    score,
    risk: getRiskLevel(score),
    summary,
    findings,
    details,
    recommendations
  };
}

// Scoring constants for API risk levels
const API_SCORE_HIGH = 5;
const API_SCORE_MEDIUM = 3;
const API_SCORE_LOW = 1;

/**
 * Check for suspicious API calls
 */
function checkSuspiciousAPIs(peData, findings) {
  let score = 0;
  const suspiciousAPIs = {
    // Very suspicious (5 points each)
    high: ['CreateRemoteThread', 'VirtualAllocEx', 'WriteProcessMemory', 'OpenProcess', 
           'LoadLibrary', 'GetProcAddress', 'WinExec', 'ShellExecute'],
    // Moderately suspicious (3 points each)
    medium: ['RegSetValue', 'RegCreateKey', 'InternetOpen', 'URLDownloadToFile',
             'CreateProcess', 'CreateFile', 'DeleteFile'],
    // Slightly suspicious (1 point each)
    low: ['Sleep', 'GetTickCount', 'GetSystemInfo', 'GetVersion']
  };

  if (!peData?.imports) return 0;

  const foundAPIs = { high: [], medium: [], low: [] };

  for (const dll of peData.imports) {
    for (const func of dll.functions) {
      if (suspiciousAPIs.high.includes(func.name)) {
        score += API_SCORE_HIGH;
        foundAPIs.high.push(func.name);
      } else if (suspiciousAPIs.medium.includes(func.name)) {
        score += API_SCORE_MEDIUM;
        foundAPIs.medium.push(func.name);
      } else if (suspiciousAPIs.low.includes(func.name)) {
        score += API_SCORE_LOW;
        foundAPIs.low.push(func.name);
      }
    }
  }

  if (foundAPIs.high.length > 0) {
    findings.push({
      title: 'High-Risk API Calls',
      description: `Found ${foundAPIs.high.length} high-risk API calls: ${foundAPIs.high.join(', ')}`,
      severity: 'high'
    });
  }

  if (foundAPIs.medium.length > 0) {
    findings.push({
      title: 'Medium-Risk API Calls',
      description: `Found ${foundAPIs.medium.length} medium-risk API calls: ${foundAPIs.medium.slice(0, 5).join(', ')}`,
      severity: 'medium'
    });
  }

  return Math.min(score, 30);
}

/**
 * Check for packer
 */
function checkPacker(peData, findings) {
  let score = 0;
  
  if (!peData?.sections) return 0;

  // Check section names
  const packerSections = ['UPX0', 'UPX1', '.aspack', '.themida', '.vmp'];
  for (const section of peData.sections) {
    if (packerSections.some(p => section.name.includes(p))) {
      score = 15;
      findings.push({
        title: 'Packer Detected',
        description: `Packed executable detected: ${section.name}`,
        severity: 'high'
      });
      break;
    }
  }

  // Check unusual section names
  const unusualSections = peData.sections.filter(s => 
    !s.name.match(/\.(text|data|rdata|rsrc|reloc)/i)
  );
  if (unusualSections.length > 2) {
    score = Math.max(score, 10);
    findings.push({
      title: 'Unusual Section Names',
      description: `Found ${unusualSections.length} sections with non-standard names`,
      severity: 'medium'
    });
  }

  return score;
}

/**
 * Check for anti-debugging techniques
 */
function checkAntiDebugging(peData, strings, findings) {
  let score = 0;

  // Check for anti-debug APIs
  const antiDebugAPIs = ['IsDebuggerPresent', 'CheckRemoteDebuggerPresent', 
                          'NtQueryInformationProcess', 'OutputDebugString'];
  
  if (peData?.imports) {
    const found = [];
    for (const dll of peData.imports) {
      for (const func of dll.functions) {
        if (antiDebugAPIs.includes(func.name)) {
          found.push(func.name);
          score += 5;
        }
      }
    }
    
    if (found.length > 0) {
      findings.push({
        title: 'Anti-Debugging Detected',
        description: `Found anti-debugging techniques: ${found.join(', ')}`,
        severity: 'high'
      });
    }
  }

  // Check strings for debugger keywords
  if (strings) {
    const debugKeywords = strings.filter(s => 
      /debug|ollydbg|ida|windbg|x64dbg/i.test(s.value)
    );
    if (debugKeywords.length > 0) {
      score += 3;
      findings.push({
        title: 'Debugger Keywords Found',
        description: `Found ${debugKeywords.length} references to debugging tools`,
        severity: 'medium'
      });
    }
  }

  return Math.min(score, 15);
}

/**
 * Check network activity
 */
function checkNetworkActivity(peData, strings, findings) {
  let score = 0;

  // Network APIs
  const networkAPIs = ['socket', 'connect', 'send', 'recv', 'WSAStartup', 
                       'InternetOpen', 'InternetConnect', 'HttpSendRequest'];
  
  if (peData?.imports) {
    let count = 0;
    for (const dll of peData.imports) {
      for (const func of dll.functions) {
        if (networkAPIs.some(api => func.name.includes(api))) {
          count++;
          score += 2;
        }
      }
    }
    
    if (count > 0) {
      findings.push({
        title: 'Network Capabilities',
        description: `Found ${count} network-related API calls`,
        severity: count > 5 ? 'high' : 'medium'
      });
    }
  }

  // Check for URLs/IPs in strings
  if (strings) {
    const urls = strings.filter(s => s.type === 'URL' || s.type === 'IP Address');
    if (urls.length > 0) {
      score += 5;
      findings.push({
        title: 'Network Addresses Found',
        description: `Found ${urls.length} URLs or IP addresses`,
        severity: 'medium'
      });
    }
  }

  return Math.min(score, 10);
}

/**
 * Check registry modification
 */
function checkRegistryModification(peData, strings, findings) {
  let score = 0;

  const regAPIs = ['RegOpenKey', 'RegCreateKey', 'RegSetValue', 'RegDeleteKey'];
  
  if (peData?.imports) {
    let count = 0;
    for (const dll of peData.imports) {
      for (const func of dll.functions) {
        if (regAPIs.some(api => func.name.includes(api))) {
          count++;
          score += 2;
        }
      }
    }
    
    if (count > 0) {
      findings.push({
        title: 'Registry Modification',
        description: `Found ${count} registry manipulation APIs`,
        severity: 'medium'
      });
    }
  }

  // Check for Run key in strings
  if (strings) {
    const runKeys = strings.filter(s => 
      /HKEY.*\\Software\\Microsoft\\Windows\\CurrentVersion\\Run/i.test(s.value)
    );
    if (runKeys.length > 0) {
      score += 5;
      findings.push({
        title: 'Autostart Registry Keys',
        description: 'Found references to autostart registry keys',
        severity: 'high'
      });
    }
  }

  return Math.min(score, 10);
}

/**
 * Check code injection
 */
function checkCodeInjection(peData, strings, findings) {
  let score = 0;

  const injectionAPIs = ['CreateRemoteThread', 'VirtualAllocEx', 'WriteProcessMemory',
                         'SetWindowsHookEx', 'NtCreateThreadEx'];
  
  if (peData?.imports) {
    const found = [];
    for (const dll of peData.imports) {
      for (const func of dll.functions) {
        if (injectionAPIs.includes(func.name)) {
          found.push(func.name);
          score += 3;
        }
      }
    }
    
    if (found.length > 0) {
      findings.push({
        title: 'Code Injection Capabilities',
        description: `Found code injection APIs: ${found.join(', ')}`,
        severity: 'high'
      });
    }
  }

  return Math.min(score, 10);
}

/**
 * Check obfuscation
 */
function checkObfuscation(analysis, findings) {
  let score = 0;

  // Check for encrypted strings
  if (analysis?.encryptedStrings > 10) {
    score += 3;
    findings.push({
      title: 'String Obfuscation',
      description: `Found ${analysis.encryptedStrings} encrypted/encoded strings`,
      severity: 'medium'
    });
  }

  return score;
}

/**
 * Check entropy
 */
function checkEntropy(peData, findings) {
  let score = 0;

  if (peData?.sections) {
    // High entropy sections might indicate encryption/compression
    const highEntropySections = peData.sections.filter(s => 
      s.entropy && s.entropy > 7.0
    );
    
    if (highEntropySections.length > 0) {
      score = 5;
      findings.push({
        title: 'High Entropy Sections',
        description: `Found ${highEntropySections.length} sections with high entropy (possibly encrypted/packed)`,
        severity: 'medium'
      });
    }
  }

  return score;
}

/**
 * Get risk level from score
 */
function getRiskLevel(score) {
  if (score < 30) return 'low';
  if (score < 70) return 'medium';
  return 'high';
}

/**
 * Generate summary
 */
function generateSummary(score, findings) {
  const level = getRiskLevel(score);
  const highFindings = findings.filter(f => f.severity === 'high').length;
  
  if (level === 'low') {
    return `Low risk detected. The executable shows ${findings.length} suspicious characteristic(s) but appears relatively benign.`;
  } else if (level === 'medium') {
    return `Medium risk detected. Found ${highFindings} high-severity and ${findings.length - highFindings} other suspicious characteristics. Exercise caution.`;
  } else {
    return `High risk detected! Found ${highFindings} high-severity indicators. This executable shows strong signs of malicious behavior.`;
  }
}

/**
 * Generate recommendations
 */
function generateRecommendations(findings) {
  const recommendations = [];

  if (findings.some(f => f.title.includes('Code Injection'))) {
    recommendations.push('‚ö†Ô∏è Code injection capabilities detected - do not run in production environment');
  }

  if (findings.some(f => f.title.includes('Network'))) {
    recommendations.push('üåê Monitor network activity if running this executable');
  }

  if (findings.some(f => f.title.includes('Registry'))) {
    recommendations.push('üìù Check registry for modifications after execution');
  }

  if (findings.some(f => f.title.includes('Packer'))) {
    recommendations.push('üì¶ Unpack the executable for better analysis');
  }

  if (findings.some(f => f.title.includes('Anti-Debug'))) {
    recommendations.push('üêõ Use advanced debugging techniques to bypass anti-debugging');
  }

  if (recommendations.length === 0) {
    recommendations.push('‚úÖ No critical security concerns detected');
  }

  return recommendations;
}
