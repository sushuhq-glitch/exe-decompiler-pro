/**
 * Rust Decompiler - Convert assembly to Rust code
 * Generates safe Rust with Result types and match expressions
 */

export function decompileToRust(instructions, peData, functionInfo) {
  const ctx = {
    code: [],
    indent: 0,
    vars: new Map(),
    peData,
    functionInfo
  };

  generateFunctionHeader(ctx);
  generateVariables(ctx, instructions);

  for (let i = 0; i < instructions.length; i++) {
    processInstruction(ctx, instructions[i]);
  }

  addLine(ctx, 'Ok(())');
  ctx.indent = 0;
  ctx.code.push('}');

  return ctx.code.join('\n');
}

function generateFunctionHeader(ctx) {
  const funcName = rustizeName(ctx.functionInfo?.name || 'function');
  
  ctx.code.push('// ' + funcName);
  if (ctx.functionInfo?.address) {
    ctx.code.push(`// Address: 0x${ctx.functionInfo.address.toString(16)}`);
  }
  ctx.code.push('// Decompiled from assembly');
  ctx.code.push(`fn ${funcName}() -> Result<(), Box<dyn std::error::Error>> {`);
  ctx.indent = 1;
}

function generateVariables(ctx, instructions) {
  const registers = ['eax', 'ebx', 'ecx', 'edx'];
  const usedRegs = new Set();

  for (const instr of instructions) {
    if (typeof instr === 'string') {
      for (const reg of registers) {
        if (instr.includes(reg)) {
          usedRegs.add(reg);
        }
      }
    }
  }

  if (usedRegs.size > 0) {
    addLine(ctx, '// Register variables');
    for (const reg of usedRegs) {
      addLine(ctx, `let mut ${reg}: u32 = 0;`);
    }
    addLine(ctx, '');
  }
}

function processInstruction(ctx, instr) {
  if (typeof instr !== 'string') return;
  
  const line = instr.trim();
  if (!line) return;

  addLine(ctx, `// ${line}`);

  const parts = line.split(/\s+/);
  const opcode = parts[0]?.toLowerCase();

  switch (opcode) {
    case 'mov':
      const ops = parts.slice(1).join(' ').split(',').map(s => s.trim());
      if (ops.length === 2) {
        addLine(ctx, `${ops[0]} = ${ops[1]};`);
      }
      break;
    case 'call':
      addLine(ctx, `${rustizeName(parts[1])}()?;`);
      break;
    default:
      addLine(ctx, `// TODO: ${opcode}`);
  }
}

function rustizeName(name) {
  return name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
}

function addLine(ctx, line) {
  const indent = '    '.repeat(ctx.indent);
  ctx.code.push(indent + line);
}

export function generateCompleteRust(functions, peData) {
  let code = [];
  
  code.push('// Decompiled Rust Code');
  code.push('// Generated by EXE Decompiler Pro');
  code.push('');
  code.push('use std::error::Error;');
  code.push('');
  code.push('fn main() -> Result<(), Box<dyn Error>> {');
  code.push('    println!("Decompiled program");');
  code.push('    Ok(())');
  code.push('}');
  code.push('');

  for (const func of functions) {
    code.push(func.code || '// Function code not available');
    code.push('');
  }

  return code.join('\n');
}
